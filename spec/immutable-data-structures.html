<!DOCTYPE html>
<meta charset="utf8" />

<emu-clause id="sec-primitive-data-structures">
  <h1>Immutable Data Structures</h1>

  <emu-clause id="sec-record-objects">
    <h1>Record Objects</h1>
    <emu-clause id="sec-record-constructor">
      <h1>The Record Constructor</h1>
      <p>The Record constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%Record%</dfn>.</li>
        <li>is the initial value of the *"Record"* property of the global object.</li>
        <li>creates and initializes a new Record value when called as a function.</li>
        <li>is not intended to be used with the `new` operator or to be subclassed. It may be used as the value of an *extends* clause of a class definition but a *super* call to the Record constructor will cause an exception.</li>
      </ul>
      <emu-clause id="sec-record-constructor-record-value">
        <h1>Record ( _arg_ )</h1>
        <p>When the `Record` function is called, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is not *undefined*, throw a *TypeError* exception.
          1. Let _obj_ be ? ToObject(_arg_).
          1. Let _keys_ be ? _obj_.[[OwnPropertyKeys]]().
          1. Let _fields_ be a new empty List.
          1. For each element _key_ of _keys_, do
            1. Let _desc_ be ? _obj_.[[GetOwnProperty]](_key_).
            1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then
              1. If Type(_key_) is Symbol, throw a *TypeError* exception.
              1. Let _value_ be ? Get(_obj_, _key_).
              1. If Type(_value_) is Object, throw a *TypeError* exception.
              1. Let _field_ be the Record { [[Key]]: _key_, [[Value]]: _value_ }.
              1. Append _field_ to the end of list _fields_.
          1. Return CreateRecord(_fields_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
    <emu-clause id="sec-properties-of-the-record-constructor">
      <h1>Properties of the Record Constructor</h1>
      <p>The Record constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>
      <emu-clause id="sec-record.fromentries">
        <h1>Record.fromEntries ( _iterable_ )</h1>
        <p>The *fromEntries* function takes one argument _iterable_, and performs the following steps:</p>
        <emu-alg>
          1. Perform ? RequireObjectCoercible(_iterable_).
          1. Let _fields_ be a new empty List.
          1. Let _adder_ be a new Abstract Closure with parameters (_key_, _value_) that captures _fields_ and performs the following steps when called:
            1. Let _keyString_ be ? ToString(_key_).
            1. If Type(_value_) is Object, throw a *TypeError* exception.
            1. Let _field_ be { [[Key]]: _keyString_, [[Value]]: _value_ }.
            1. Append _field_ to the end of list _fields_.
          1. Perform ? AddEntriesFromIterable(*undefined*, _iterable_, _adder_).
          1. Let _uniqueEntries_ be DeduplicateRecordEntries(_fields_).
          1. Return CreateRecord(_uniqueEntries_).
        </emu-alg>
        <emu-note>
          <p>The parameter _iterable_ is expected to be an object that implements an @@iterator method that returns an iterator object that produces a two element array-like object whose first element is a value that will be used as a Map key and whose second element is the value to associate with that key.</p>
        </emu-note>
      </emu-clause>
      <emu-clause id="sec-record-@@hasinstance">
        <h1>Record [ @@hasInstance ] ( _V_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. If _V_ is an Object and _V_ has a [[RecordData]] internal slot, return *true*. Otherwise, return *false*.
        </emu-alg>
        <emu-note>
          <p>The Record constructor overrides the `@@hasInstance` because unlike the other primitives its prototype is *null*.</p>
          <p>For example,</p>
          <pre><code class="javascript">
            Object(#{}) instanceof Record
          </code></pre>
          <p>will return *true* instead of throwing a *TypeError*.</p>
          <p>The method checks for the [[RecordData]] internal slot instead of checking for a *null* [[prototype]] because all prototype chains that terminate end with *null*. So,</p>
          <pre><code class="javascript">
            Object.create(null) instanceof Record
          </code></pre>
          <p>will return *false*.</p>
        </emu-note>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        <p>The value of the *"name"* property of this method is *"[Symbol.hasInstance]"*.</p>
      </emu-clause>
      <emu-clause id="sec-record.prototype">
        <h1>Record.prototype</h1>
        <p>The initial value of *Record.prototype* is the value *null*.</p>

        <p>This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</p>
      </emu-clause>
    </emu-clause>
    <emu-clause id="sec-properties-of-record-objects">
      <h1>Properties of Record Objects</h1>
      <p>Record objects are ordinary objects with a *null* prototype. Record objects have a [[RecordData]] internal slot. The [[RecordData]] internal slot is the Record value represented by this Record object.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-tuple-objects">
    <h1>Tuple Objects</h1>
    <emu-clause id="sec-tuple-constructor">
      <h1>The Tuple Constructor</h1>
      <p>The Tuple constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%Tuple%</dfn>.</li>
        <li>is the initial value of the *"Tuple"* property of the global object.</li>
        <li>creates and initializes a new Tuple object when called as a function.</li>
        <li>is not intended to be used with the `new` operator or to be subclassed. It may be used as the value of an *extends* clause of a class definition but a *super* call to the Tuple constructor will cause an exception.</li>
      </ul>
      <emu-clause id="sec-tuple-items">
        <h1>Tuple ( ..._items_ )</h1>
        <p>When the `Tuple` function is called with zero or more arguments, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is not *undefined*, throw a *TypeError* exception.
          1. Let _items_ be the List of arguments passed to this function.
          1. For each element _e_ of _items_, do
            1. If Type(_e_) is Object, throw a *TypeError* exception.
          1. Let _tuple_ be a new Tuple value whose [[Sequence]] is _items_.
          1. Return _tuple_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
    <emu-clause id="sec-properties-of-the-tuple-constructor">
      <h1>Properties of the Tuple Constructor</h1>
      <p>The Tuple constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>
      <emu-clause id="sec-tuple.from">
        <h1>Tuple.from ( _items_ [ , _mapfn_ [ , _thisArg_ ] ] )</h1>
        <p>When the `from` method is called with argument _items_ and optional arguments _mapfn_ and _thisArg_, the following steps are taken:</p>
        <emu-alg>
          1. If _mapfn_ is *undefined*, let _mapping_ be *false*.
          1. Else,
            1. If IsCallable(_mapfn_) is *false*, throw a *TypeError* exception.
            1. Let _mapping_ be *true*.
          1. Let _list_ be a new empty List.
          1. Let _k_ be 0.
          1. Let _usingIterator_ be ? GetMethod(_items_, @@iterator).
          1. If _usingIterator_ is not *undefined*, then
            1. Let _closure_ be a new Abstract Closure with parameter (_value_) that captures (_list_, _mapFn_, _thisArg_, _mapping_, _k_) and performs the following steps when called:
              1. If _k_ &ge; 2<sup>53</sup> - 1, throw a *TypeError* exception.
              1. If _mapping_ is *true*, then
                1. Let _mappedValue_ be ? Call(_mapfn_, _thisArg_, &laquo; _value_, ùîΩ(_k_) &raquo;).
              1. Else, let _mappedValue_ be _value_.
              1. If Type(_mappedValue_) is Object, throw a *TypeError* exception.
              1. Append _mappedValue_ to _list_.
              1. Set _k_ to _k_ + 1.
            1. Let _adder_ be CreateBuiltinFunction(_closure_, 1, *""*, &laquo; &raquo;).
            1. Perform ? AddValuesFromIterable(*undefined*, _items_, _adder_, _usingIterator_).
            1. Return a new Tuple value whose [[Sequence]] is _list_.
          1. NOTE: _items_ is not an Iterable so assume it is an array-like object.
          1. Let _arrayLike_ be ! ToObject(_items_).
          1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).
            1. If _mapping_ is *true*, then
              1. Let _mappedValue_ be ? Call(_mapfn_, _thisArg_, &laquo; _kValue_, _k_ &raquo;).
            1. Else, let _mappedValue_ be _kValue_.
            1. If Type(_mappedValue_) is Object, throw a *TypeError* exception.
            1. Append _mappedValue_ to _list_.
            1. Set _k_ to _k_ + 1.
          1. Return a new Tuple value whose [[Sequence]] is _list_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.of">
        <h1>Tuple.of ( ..._items_ )</h1>
        <p>The *of* method takes any number of arguments, and performs the following steps:</p>
        <emu-alg>
          1. Let _items_ be the List of arguments passed to this function.
          1. For each element _e_ of _items_, do
            1. If Type(_e_) is Object, throw a *TypeError* exception.
          1. Let _tuple_ be a new Tuple value whose [[Sequence]] is _items_.
          1. Return _tuple_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype">
        <h1>Tuple.prototype</h1>
        <p>The initial value of *Tuple.prototype* is %Tuple.prototype%.</p>
        <p>This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</p>
      </emu-clause>
    </emu-clause>
    <emu-clause id="sec-properties-of-the-tuple-prototype-object">
      <h1>Properties of the Tuple Prototype Object</h1>
      <p>The Tuple prototype object:</p>
      <ul>
        <li>is an ordinary object.</li>
        <li>is not a Tuple object; it does not have a [[TupleData]] internal slot.</li>
        <li>has a [[Prototype]] internal slot whose value is *null*.</li>
      </ul>
      <emu-clause id="sec-thistuplevalue" type="abstract operation">
        <h1>
          <ins>
            thisTupleValue (
              _value_: unknown,
            ): either a normal completion containing a Tuple or a throw completion
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It throws an exception unless _O_ is an Object and has the given internal slot.</dd>
        </dl>
        <emu-alg>
          1. If Type(_value_) is Tuple, return _value_.
          1. If Type(_value_) is Object and _value_ has a [[TupleData]] internal slot, then
            1. Let _t_ be _value_.[[TupleData]].
            1. Assert: Type(_t_) is Tuple.
            1. Return _t_.
          1. Throw a *TypeError* exception.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-tuple.prototype.constructor">
        <h1>Tuple.prototype.constructor</h1>
        <p>The initial value of *Tuple.prototype.constructor* is the intrinsic object %Tuple%.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.at">
        <h1>Tuple.prototype.at ( _index_ )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.at` as defined in <emu-xref href="#sec-array.prototype.at"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _elements_ be _T_.[[Sequence]].
          1. Let _len_ be the length of _elements_.
          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).
          1. If _relativeIndex_ &ge; 0, then
            1. Let _k_ be _relativeIndex_.
          1. Else,
            1. Let _k_ be _len_ + _relativeIndex_.
          1. If _k_ &lt; 0 or _k_ &ge; _len_, return *undefined*.
          1. Return _elements_[_k_].
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.valueof">
        <h1>Tuple.prototype.valueOf ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Return ? thisTupleValue(*this* value).
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype-@@toStringTag">
        <h1>Tuple.prototype [ @@toStringTag ]</h1>
        <p>The initial value of *Tuple.prototype[@@toStringTag]* is the String value *"Tuple"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.slice">
        <h1>Tuple.prototype.slice ( _start_, _end_ )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.slice` as defined in <emu-xref href="#sec-array.prototype.slice"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _list_.
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ is -&infin;, let _k_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _k_ be max((_len_ + _relativeStart_), 0); else let _k_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ is -&infin;, let _final_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_), 0); else let _final_ be min(_relativeEnd_, _len_).
          1. Let _newList_ be a new empty List.
          1. Repeat, while _k_ &lt; _final_,
            1. Let _kValue_ be _list_[_k_].
            1. Assert: Type(_kValue_) is not Object.
            1. Append _kValue_ to the end of _newList_.
            1. Set _k_ to _k_ + 1.
          1. Return a new Tuple value whose [[Sequence]] is _newList_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.concat">
        <h1>Tuple.prototype.concat ( ..._args_ )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.concat` as defined in <emu-xref href="#sec-array.prototype.concat"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be a new empty List.
          1. Let _n_ be 0.
          1. Let _items_ be a List whose first element is _T_ and whose subsequent element are, in left to right order, the arguments that were passed to this function invocation.
          1. Repeat, while _items_ is not empty,
            1. Remove the first element from _items_ and let _E_ be the value of the element.
            1. Let _spreadable_ be ? IsArrayOrTuple(_E_).
            1. If _spreadable_ is *true*, then
              1. Set _E_ to ! ToObject(_E_).
              1. Let _k_ be 0.
              1. Let _len_ be ? LengthOfArrayLike(_E_).
              1. If _n_ + _len_ &gt; 2<sup>53</sup> - 1, throw a *TypeError* exception.
              1. Repeat, while _k_ &lt; _len_,
                1. Let _P_ be ! ToString(_k_).
                1. Let _exists_ be ? HasProperty(_E_, _P_).
                1. If _exists_ is *true*, then
                  1. Let _subElement_ be ? Get(_E_, _P_).
                  1. If Type(_subElement_) is Object, throw a *TypeError* exception.
                  1. Append _subElement_ to the end of list _list_.
                1. Set _n_ to _n_ + 1.
                1. Set _k_ to _k_ + 1.
            1. Else,
              1. NOTE: _E_ is added as a single item rather than spread.
              1. If _n_ &ge; 2<sup>53</sup> - 1, throw a *TypeError* exception.
              1. If Type(_E_) is Object, throw a *TypeError* exception.
              1. Append _E_ to the end of list _list_.
              1. Set _n_ to _n_ + 1.
          1. Return a new Tuple value whose [[Sequence]] is _list_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.includes">
        <h1>Tuple.prototype.includes ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.includes` as defined in <emu-xref href="#sec-array.prototype.includes"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _elements_ be _T_.[[Sequence]].
          1. Let _len_ be the length of _elements_.
          1. If _len_ is 0, return *false*.
          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).
          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.
          1. If _n_ is +&infin;, return *false*.
          1. Else if _n_ is -&infin;, set _n_ to 0.
          1. If _n_ &ge; 0, then
            1. Let _k_ be _n_.
          1. Else,
            1. Let _k_ be _len_ + _n_.
            1. If _k_ &lt; 0, set _k_ to 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _elementK_ be _elements_[_k_].
            1. If SameValueZero(_searchElement_, _elementK_) is *true*, return *true*.
            1. Set _k_ to _k_ + 1.
          1. Return *false*.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.indexof">
        <h1>Tuple.prototype.indexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.indexOf` as defined in <emu-xref href="#sec-array.prototype.indexof"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _elements_ be _T_.[[Sequence]].
          1. Let _len_ be the length of _elements_.
          1. If _len_ is 0, return *-1*<sub>ùîΩ</sub>.
          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).
          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.
          1. If _n_ is +&infin;, return *-1*<sub>ùîΩ</sub>.
          1. Else if _n_ is -&infin;, set _n_ to 0.
          1. If _n_ &ge; 0, then
            1. Let _k_ be _n_.
          1. Else,
            1. Let _k_ be _len_ + _n_.
            1. If _k_ &lt; 0, set _k_ to 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _elementK_ be _elements_[_k_].
            1. Let _same_ be IsStrictlyEqual(_searchElement_, _elementK_).
            1. If _same_ is *true*, return ùîΩ(_k_).
            1. Set _k_ to _k_ + 1.
          1. Return *-1*<sub>ùîΩ</sub>.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.join">
        <h1>Tuple.prototype.join ( _separator_ )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.join` as defined in <emu-xref href="#sec-array.prototype.join"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _elements_ be _T_.[[Sequence]].
          1. Let _len_ be the length of _elements_.
          1. If _separator_ is *undefined*, let _sep_ be *","*.
          1. Else, let _sep_ be ? ToString(_separator_).
          1. Let _R_ be the empty String.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. If _k_ &gt; 0, set _R_ to the string-concatenation of _R_ and _sep_.
            1. Let _elementK_ be _elements_[_k_].
            1. If _elementK_ is *undefined* or *null*, let _next_ be the empty String; otherwise, let _next_ be ? ToString(_elementK_).
            1. Set _R_ to the string-concatenation of _R_ and _next_.
            1. Set _k_ to _k_ + 1.
          1. Return _R_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.lastindexof">
        <h1>Tuple.prototype.lastIndexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.lastIndexOf` as defined in <emu-xref href="#sec-array.prototype.lastindexof"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _elements_ be _T_.[[Sequence]].
          1. Let _len_ be the length of _elements_.
          1. If _len_ is 0, return *-1*<sub>ùîΩ</sub>.
          1. If _fromIndex_ is present, let _n_ be ? ToIntegerOrInfinity(_fromIndex_); else let _n_ be _len_ - 1.
          1. If _n_ is -&infin;, return *-1*<sub>ùîΩ</sub>.
          1. If _n_ &ge; 0, then
            1. Let _k_ be min(_n_, _len_ - 1).
          1. Else,
            1. Let _k_ be _len_ + _n_.
          1. Repeat, while _k_ &ge; 0,
            1. Let _elementK_ be _elements_[_k_].
            1. Let _same_ be IsStrictlyEqual(_searchElement_, _elementK_).
            1. If _same_ is *true*, return ùîΩ(_k_).
            1. Set _k_ to _k_ - 1.
          1. Return *-1*<sub>ùîΩ</sub>.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.entries">
        <h1>Tuple.prototype.entries ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _tuple_ be ? thisTupleValue(*this* value).
          1. Let _O_ be ! ToObject(_tuple_).
          1. Return CreateArrayIterator(_O_, ~key+value~).
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.every">
        <h1>Tuple.prototype.every ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.every` as defined in <emu-xref href="#sec-array.prototype.every"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _elements_ be _T_.[[Sequence]].
          1. Let _len_ be the length of _elements_.
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _kValue_ be _elements_[_k_].
            1. Let _testResult_ be ToBoolean(? Call(_callbackfn_, _thisArg_, &laquo; _kValue_, ùîΩ(_k_), _T_ &raquo;)).
            1. If _testResult_ is *false*, return *false*.
            1. Set _k_ to _k_ + 1.
          1. Return *true*.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.filter">
        <h1>Tuple.prototype.filter ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.filter` as defined in <emu-xref href="#sec-array.prototype.filter"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _list_.
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. Let _newList_ be a new empty List.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _kValue_ be _list_[_k_].
            1. Let _selected_ be ToBoolean(? Call(_callbackfn_, _thisArg_, &laquo; _kValue_, _k_, _T_ &raquo;)).
            1. If _selected_ is *true*, then
              1. Append _kValue_ to the end of list _newList_.
            1. Set _k_ to _k_ + 1.
          1. Return a new Tuple value whose [[Sequence]] is _newList_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.find">
        <h1>Tuple.prototype.find ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.find` as defined in <emu-xref href="#sec-array.prototype.find"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _elements_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _elements_.
          1. If IsCallable(_predicate_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _kValue_ be ? _elements_[_k_].
            1. Let _testResult_ be ToBoolean(? Call(_predicate_, _thisArg_, &laquo; _kValue_, ùîΩ(_k_), _T_ &raquo;)).
            1. If _testResult_ is *true*, return _kValue_.
            1. Set _k_ to _k_ + 1.
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.findindex">
        <h1>Tuple.prototype.findIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.findIndex` as defined in <emu-xref href="#sec-array.prototype.findindex"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _elements_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _elements_.
          1. If IsCallable(_predicate_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _kValue_ be ? _elements_[_k_].
            1. Let _testResult_ be ToBoolean(? Call(_predicate_, _thisArg_, &laquo; _kValue_, ùîΩ(_k_), _T_ &raquo;)).
            1. If _testResult_ is *true*, return ùîΩ(_k_).
            1. Set _k_ to _k_ + 1.
          1. Return *-1*<sub>ùîΩ</sub>.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.findlast">
        <h1>Tuple.prototype.findLast ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.findLast` as defined in <emu-xref href="#sec-array.prototype.findlast"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _elements_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _elements_.
          1. If IsCallable(_predicate_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be _len_ - 1.
          1. Repeat, while _k_ &ge; 0,
            1. Let _kValue_ be _elements_[_k_].
            1. Let _testResult_ be ToBoolean(? Call(_predicate_, _thisArg_, &laquo; _kValue_, ùîΩ(_k_), _T_ &raquo;)).
            1. If _testResult_ is *true*, return _kValue_.
            1. Set _k_ to _k_ - 1.
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.findlastindex">
        <h1>Tuple.prototype.findLastIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.findLsatIndex` as defined in <emu-xref href="#sec-array.prototype.findlastindex"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _elements_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _elements_.
          1. If IsCallable(_predicate_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be _len_ - 1.
          1. Repeat, while _k_ &ge; 0,
            1. Let _kValue_ be _elements_[_k_].
            1. Let _testResult_ be ToBoolean(? Call(_predicate_, _thisArg_, &laquo; _kValue_, ùîΩ(_k_), _T_ &raquo;)).
            1. If _testResult_ is *true*, return ùîΩ(_k_).
            1. Set _k_ to _k_ - 1.
          1. Return *-1*<sub>ùîΩ</sub>.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.flat">
        <h1>Tuple.prototype.flat ( [ _depth_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.flat` as defined in <emu-xref href="#sec-array.prototype.flat"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be _T_.[[Sequence]].
          1. Let _depthNum_ be 1.
          1. If _depth_ is not *undefined*, then
            1. Set _depthNum_ to ? ToIntegerOrInfinity(_depth_).
          1. Let _flat_ be a new empty List.
          1. Perform ? FlattenIntoTuple(_flat_, _list_, _depthNum_).
          1. Return a new Tuple value whose [[Sequence]] is _flat_.
        </emu-alg>

        <emu-clause id="sec-flattenintotuple" aoid="FlattenIntoTuple">
          <h1>FlattenIntoTuple ( _target_, _source_, _depth_ [ , _mapperFunction_, _thisArg_ ] )</h1>
          <p>The abstract operation FlattenIntoTuple takes arguments _target_, _source_, and _depth_ and optional arguments _mapperFunction_ and _thisArg_. It performs the following steps when called:</p>
          <emu-alg>
            1. Assert: _target_ is a List.
            1. Assert: _source_ is a List.
            1. Assert: IsIntegralNumber(_depth_) is *true*, or _depth_ is either *+&infin;*<sub>ùîΩ</sub> or *-&infin;*<sub>ùîΩ</sub>.
            1. Assert: If _mapperFunction_ is present, then IsCallable(_mapperFunction_) is *true*, _thisArg_ is present, and _depth_ is 1.
            1. Let _sourceIndex_ be 0.
            1. For each element _element_ of _source_, do
              1. If _mapperFunction_ is present, then
                1. Set _element_ to ? Call(_mapperFunction_, _thisArg_, &laquo; _element_, _sourceIndex_, _source_ &raquo;).
                1. If Type(_element_) is Object, throw a *TypeError* exception.
              1. If _depth_ &gt; 0 and Type(_element_) is Tuple, then
                1. Perform ? FlattenIntoTuple(_target_, _element_, _depth_ - 1).
              1. Else,
                1. Let _len_ be the length of _target_.
                1. If _len_ &ge; 2<sup>53</sup> - 1, throw a *TypeError* exception.
                1. Append _element_ to _target_.
              1. Set _sourceIndex_ to _sourceIndex_ + 1.
          </emu-alg>
        </emu-clause>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.flatmap">
        <h1>Tuple.prototype.flatMap ( _mapperFunction_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.flatMap` as defined in <emu-xref href="#sec-array.prototype.flatmap"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be _T_.[[Sequence]].
          1. If IsCallable(_mapperFunction_) is *false*, throw a *TypeError* exception.
          1. Let _flat_ be a new empty List.
          1. Perform ? FlattenIntoTuple(_flat_, _list_, 1, _mapperFunction_, _thisArg_).
          1. Return a new Tuple value whose [[Sequence]] is _flat_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.foreach">
        <h1>Tuple.prototype.forEach ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.forEach` as defined in <emu-xref href="#sec-array.prototype.foreach"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _elements_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _elements_.
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _kValue_ be _elements_[_k_].
            1. Perform ? Call(_callbackfn_, _thisArg_, &laquo; _kValue_, ùîΩ(_k_), T &raquo;).
            1. Set _k_ to _k_ + 1.
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.keys">
        <h1>Tuple.prototype.keys ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _tuple_ be ? thisTupleValue(*this* value).
          1. Let _O_ be ! ToObject(_tuple_).
          1. Return CreateArrayIterator(_O_, ~key~).
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.map">
        <h1>Tuple.prototype.map ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.map` as defined in <emu-xref href="#sec-array.prototype.map"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _list_.
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. Let _newList_ be a new empty List.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _kValue_ be _list_[_k_].
            1. Let _mappedValue_ be ? Call(_callbackfn_, _thisArg_, &laquo; _kValue_, _k_, _T_ &raquo;).
            1. If Type(_mappedValue_) is Object, throw a *TypeError* exception.
            1. Append _mappedValue_ to the end of list _newList_.
            1. Set _k_ to _k_ + 1.
          1. Return a new Tuple value whose [[Sequence]] is _newList_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.reduce">
        <h1>Tuple.prototype.reduce ( _callbackfn_ [ , _initialValue_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.reduce` as defined in <emu-xref href="#sec-array.prototype.reduce"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _elements_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _elements_.
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Let _accumulator_ be *undefined*.
          1. If _initialValue_ is present, then
            1. Set _accumulator_ to _initialValue_.
          1. Else,
            1. Set _accumulator_ to the first element of _elements_.
            1. Set _k_ to 1.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _kValue_ be _elements_[_k_].
            1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, &laquo; _accumulator_, _kValue_, ùîΩ(_k_), _T_ &raquo;).
            1. Set _k_ to _k_ + 1.
          1. Return _accumulator_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.reduceright">
        <h1>Tuple.prototype.reduceRight ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.reduceRight` as defined in <emu-xref href="#sec-array.prototype.reduceright"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _elements_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _elements_.
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. If _len_ is 0 and _initialValue_ is not present, throw a *TypeError* exception.
          1. Let _k_ be _len_ - 1.
          1. Let _accumulator_ be *undefined*.
          1. If _initialValue_ is present, then
            1. Set _accumulator_ to _initialValue_.
          1. Else,
            1. Set _accumulator_ to the last element of _elements_.
            1. Set _k_ to _k_ - 1.
          1. Repeat, while _k_ &ge; 0,
            1. Let _kValue_ be _elements_[_k_].
            1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, &laquo; _accumulator_, _kValue_, ùîΩ(_k_), _T_ &raquo;).
            1. Set _k_ to _k_ - 1.
          1. Return _accumulator_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.some">
        <h1>Tuple.prototype.some ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.some` as defined in <emu-xref href="#sec-array.prototype.some"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _elements_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _elements_.
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _kValue_ be _elements_[_k_].
            1. Let _testResult_ be ToBoolean(? Call(_callbackfn_, _thisArg_, &laquo; _kValue_, ùîΩ(_k_), _T_ &raquo;)).
            1. If _testResult_ is *true*, return *true*.
            1. Set _k_ to _k_ + 1.
          1. Return *false*.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.tolocalestring">
        <h1>Tuple.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.toLocaleString` as defined in <emu-xref href="#sec-array.prototype.tolocalestring"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _elements_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _elements_.
          1. Let _separator_ be the implementation-defined list-separator String value appropriate for the host environment's current locale (such as *", "*).
          1. Let _R_ be the empty String.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. If _k_ &gt; 0, then
              1. Set _R_ to the string-concatenation of _R_ and _separator_.
            1. Let _nextElement_ be _elements_[_k_].
            1. If _nextElement_ is not *undefined* or *null*, then
              1. Let _S_ be ? ToString(? Invoke(_nextElement_, *"toLocaleString"*)).
              1. Set _R_ to the string-concatenation of _R_ and _S_.
            1. Set _k_ to _k_ + 1.
          1. Return _R_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.tostring">
        <h1>Tuple.prototype.toString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _tuple_ be ? thisTupleValue(*this* value).
          1. Return TupleToString(_tuple_).
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.values">
        <h1>Tuple.prototype.values ( )</h1>
        <p>When the *values* method is called, it returns an iterator over the values of the Tuple.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _tuple_ be ? thisTupleValue(*this* value).
          1. Let _O_ be ! ToObject(_tuple_).
          1. Return CreateArrayIterator(_O_, ~value~).
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype-@@iterator">
        <h1>Tuple.prototype [ @@iterator ] ( )</h1>
        <p>The initial value of the @@iterator property is %Tuple.prototype.values%.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.toReversed">
        <h1>Tuple.prototype.toReversed ( )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.reverse` as defined in <emu-xref href="#sec-array.prototype.reverse"></emu-xref>, but it creates a new tuple rather than mutating its receiver.</p>
        <emu-note type="editor">
          Once the Change Array by Copy proposal reaches stage 4, the above paragraph will be updated to reference `Array.prototype.toReversed`.
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _oldList_ be a new List containing the elements of _T_.[[Sequence]].
          1. Let _newList_ be a new empty List.
          1. Repeat, while _oldList_ is not empty,
            1. Remove the last element from _oldList_, and let _E_ be the value of the element.
            1. Append _E_ to the end of List _newList_.
          1. Return a new Tuple value whose [[Sequence]] is _newList_.
        </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tuple.prototype.toSorted">
        <h1>Tuple.prototype.toSorted ( _comparefn_ )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.sort` as defined in <emu-xref href="#sec-array.prototype.sort"></emu-xref>, but it creates a new tuple rather than mutating its receiver.</p>
        <emu-note type="editor">
          Once the Change Array by Copy proposal reaches stage 4, the above paragraph will be updated to reference `Array.prototype.toSorted`.
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be a new List containing the elements of _T_.[[Sequence]].
          1. Sort _list_ using an implementation-defined sequence of calls to SortCompare. If any such call returns an abrupt completion, stop before performing any further calls to SortCompare or steps in this algorithm and return that completion.
          1. Return a new Tuple value whose [[Sequence]] is _list_.
        </emu-alg>
        <p>The elements of _list_ are sorted in the same order as if they were sorted in an Array via %Array.prototype.sort% with _comparefn_ as the first argument.</p>
    </emu-clause>

    <emu-clause id="sec-tuple.prototype.toSpliced">
        <h1>Tuple.prototype.toSpliced ( _start_, _deleteCount_, ..._items_ )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.splice` as defined in <emu-xref href="#sec-array.prototype.splice"></emu-xref>, but it creates a new tuple rather than mutating its receiver.</p>
        <emu-note type="editor">
          Once the Change Array by Copy proposal reaches stage 4, the above paragraph will be updated to reference `Array.prototype.toSpliced`.
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _list_.
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ &lt; 0, let _actualStart_ be max((_len_ + _relativeStart_), 0); else let _actualStart_ be min(_relativeStart_, _len_).
          1. If the number of actual arguments is 0, then
            1. Let _insertCount_ be 0.
            1. Let _actualDeleteCount_ be 0.
          1. Else if the number of actual arguments is 1, then
            1. Let _insertCount_ be 0.
            1. Let _actualDeleteCount_ be _len_ - _actualStart_.
          1. Else,
            1. Let _insertCount_ be the number of actual arguments minus 2.
            1. Let _dc_ be ? ToIntegerOrInfinity(_deleteCount_).
            1. Let _actualDeleteCount_ be min(max(_dc_, 0), _len_ - _actualStart_).
          1. If _len_ + _insertCount_ - _actualDeleteCount_ &gt; 2<sup>53</sup> - 1, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Let _items_ be a List whose elements are, in left to right order, the portion of the actual argument list starting with the third argument. The list is empty if fewer than three arguments were passed.
          1. Let _itemCount_ be the number of elements in _items_.
          1. Let _newList_ be a new empty List.
          1. Repeat, while _k_ &lt; _actualStart_,
            1. Let _E_ be _list_[_k_].
            1. Append _E_ to the end of list _newList_.
            1. Set _k_ to _k_ + 1.
          1. Let _itemK_ be 0.
          1. Repeat, while _itemK_ &lt; _itemCount_,
            1. Let _E_ be _items_[_itemK_].
            1. If Type(_E_) is Object, throw a *TypeError* exception.
            1. Append _E_ to the end of _newList_.
            1. Set _itemK_ to _itemK_ + 1.
          1. Set _k_ to _actualStart_ + _actualDeleteCount_.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _E_ be _list_[_k_].
            1. Append _E_ to the end of _newList_.
            1. Set _k_ to _k_ + 1.
          1. Return a new Tuple value whose [[Sequence]] is _newList_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.with">
        <h1>Tuple.prototype.with ( _index_, _value_ )</h1>
        <emu-note type="editor">
          Once the Change Array by Copy proposal reaches stage 4, this method will have the same introduction used for all the other methods and it will reference `Array.prototype.with`.
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be a new List containing the elements of _T_.[[Sequence]].
          1. Let _length_ be the length of list _list_.
          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).
          1. If _index_ &ge; 0, let _actualIndex_ be _relativeIndex_.
          1. Else, let _actualIndex_ be _len_ + _relativeIndex_.
          1. If _actualIndex_ &ge; _len_ or _actualIndex_ &lt; 0, throw a *RangeError* exception.
          1. If Type(_value_) is Object, throw a *TypeError* exception.
          1. Set _list_[_actualIndex_] to _value_.
          1. Return a new Tuple value whose [[Sequence]] is _list_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
